<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Go 统一日志处理 - ruanzhijun</title>
  <meta charset="UTF-8">
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/images/favicon.jpg" type="image/jpg" />
  <meta name="description" content="简介在现代软件开发中，日志记录是一项至关重要的任务，它不仅帮助开发人员诊断问题，还有助于监控和维护应用程序。在Go语言中，性能和内存分配是至关重要的考虑因素，因此选择一个高性能的日志库非常重要。本文将介绍Uber开源的zap日志库，它在性能和内存分配方面进行了极致的优化，成为Go语言中的一种理想选择。 正题快速使用先安装： $ go get go.uber.org&#x2F;zap  后使用： packag">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 统一日志处理">
<meta property="og:url" content="https://ruanzhijun.cn/2024/11/05/go-log/index.html">
<meta property="og:site_name" content="ruanzhijun">
<meta property="og:description" content="简介在现代软件开发中，日志记录是一项至关重要的任务，它不仅帮助开发人员诊断问题，还有助于监控和维护应用程序。在Go语言中，性能和内存分配是至关重要的考虑因素，因此选择一个高性能的日志库非常重要。本文将介绍Uber开源的zap日志库，它在性能和内存分配方面进行了极致的优化，成为Go语言中的一种理想选择。 正题快速使用先安装： $ go get go.uber.org&#x2F;zap  后使用： packag">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-11-05T05:04:21.000Z">
<meta property="article:modified_time" content="2024-11-05T05:08:11.241Z">
<meta property="article:author" content="ruanzhijun">
<meta property="article:tag" content="go">
<meta property="article:tag" content="日志">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/nexmoe/nexmoe.github.io@latest/css/style.css,npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css" crossorigin>
  
  <!--<link rel="stylesheet" href="/css/style.css?v=1730783323603">-->

  
<meta name="generator" content="Hexo 7.3.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url()"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="ruanzhijun" class="mdui-btn mdui-btn-icon"><img src="/images/favicon.jpg" alt="ruanzhijun"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="ruanzhijun">
            <img src="/images/favicon.jpg" alt="ruanzhijun" alt="ruanzhijun">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>5</div>
        <div><span>标签</span>7</div>
        <div><span>分类</span>2</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/ruanzhijun/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/技术文章/">技术文章</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/运维相关/">运维相关</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">标签云</h3>
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/quic/" style="font-size: 10px;">quic</a> <a href="/tags/rtmp/" style="font-size: 10px;">rtmp</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 10px;">多线程</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E7%9B%B4%E6%92%AD/" style="font-size: 10px;">直播</a>
    </div>
    
  </div>

  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li></ul>
    </div>
  </div>


  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2024/11/05/go-log/">Go 统一日志处理</a>
          </li>
        
          <li>
            <a href="/2024/11/02/goroutine/">Go Goroutine 究竟可以开多少</a>
          </li>
        
          <li>
            <a href="/2024/10/31/go-context/">Go语言中的context包到底解决了啥问题？</a>
          </li>
        
          <li>
            <a href="/2020/07/16/nginx-rtmp/">nginx+rtmp搭建直播服务器</a>
          </li>
        
          <li>
            <a href="/2020/07/10/nginx-quic/">nginx原生支持quic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
    <div class="nexmoe-copyright">
        &copy; 2024 ruanzhijun
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
        <br><a href="http://beian.miit.gov.cn/" target="_blank">京ICP备16028275号-1</a>
    </div>
</div><!-- .nexmoe-drawer -->

  </div>
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <div class="nexmoe-post">
  
      <div class="nexmoe-post-cover" style="padding-bottom: NaN%;"> 
          <img data-src="/images/go-log/cover.jpeg" data-sizes="auto" alt="Go 统一日志处理" class="lazyload">
          <h1>Go 统一日志处理</h1>
      </div>
  
  
  <div class="nexmoe-post-meta nexmoe-rainbow" style="margin:10px 0!important;">
    <a><i class="nexmoefont icon-calendar-fill"></i>2024年11月05日</a>
    <a><i class="nexmoefont icon-areachart"></i>3.9k 字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>大概 20 分钟</a>
</div>

  <div class="nexmoe-post-right">
    
  </div>

  <article>
    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在现代软件开发中，日志记录是一项至关重要的任务，它不仅帮助开发人员诊断问题，还有助于监控和维护应用程序。在Go语言中，性能和内存分配是至关重要的考虑因素，因此选择一个高性能的日志库非常重要。本文将介绍Uber开源的zap日志库，它在性能和内存分配方面进行了极致的优化，成为Go语言中的一种理想选择。</p>
<h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>先安装：</p>
<pre><code class="hljs Linux">$ go get go.uber.org/zap</code></pre>

<p>后使用：</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
  <span class="hljs-string">&quot;time&quot;</span>

  <span class="hljs-string">&quot;go.uber.org/zap&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger := zap.NewExample()
  <span class="hljs-keyword">defer</span> logger.Sync()

  url := <span class="hljs-string">&quot;http://example.org/api&quot;</span>
  logger.Info(<span class="hljs-string">&quot;failed to fetch URL&quot;</span>,
    zap.String(<span class="hljs-string">&quot;url&quot;</span>, url),
    zap.Int(<span class="hljs-string">&quot;attempt&quot;</span>, <span class="hljs-number">3</span>),
    zap.Duration(<span class="hljs-string">&quot;backoff&quot;</span>, time.Second),
  )

  sugar := logger.Sugar()
  sugar.Infow(<span class="hljs-string">&quot;failed to fetch URL&quot;</span>,
    <span class="hljs-string">&quot;url&quot;</span>, url,
    <span class="hljs-string">&quot;attempt&quot;</span>, <span class="hljs-number">3</span>,
    <span class="hljs-string">&quot;backoff&quot;</span>, time.Second,
  )
  sugar.Infof(<span class="hljs-string">&quot;Failed to fetch URL: %s&quot;</span>, url)
&#125;</code></pre>

<p><code>zap</code>库的使用与其他的日志库非常相似。先创建一个<code>logger</code>，然后调用各个级别的方法记录日志（<code>Debug/Info/Error/Warn</code>）。<code>zap</code>提供了几个快速创建<code>logger</code>的方法，<code>zap.NewExample()</code>、<code>zap.NewDevelopment()</code>、<code>zap.NewProduction()</code>，还有高度定制化的创建方法<code>zap.New()</code>。创建前 3 个<code>logger</code>时，<code>zap</code>会使用一些预定义的设置，它们的使用场景也有所不同。<code>Example</code>适合用在测试代码中，<code>Development</code>在开发环境中使用，<code>Production</code>用在生成环境。</p>
<p><code>zap</code>底层 API 可以设置缓存，所以一般使用<code>defer logger.Sync()</code>将缓存同步到文件中。</p>
<p>由于<code>fmt.Printf</code>之类的方法大量使用<code>interface&#123;&#125;</code>和反射，会有不少性能损失，并且增加了内存分配的频次。<code>zap</code>为了提高性能、减少内存分配次数，没有使用反射，而且默认的<code>Logger</code>只支持强类型的、结构化的日志。必须使用<code>zap</code>提供的方法记录字段。<code>zap</code>为 Go 语言中所有的基本类型和其他常见类型都提供了方法。这些方法的名称也比较好记忆，<code>zap.Type</code>（<code>Type</code>为<code>bool/int/uint/float64/complex64/time.Time/time.Duration/error</code>等）就表示该类型的字段，<code>zap.Typep</code>以<code>p</code>结尾表示该类型指针的字段，<code>zap.Types</code>以<code>s</code>结尾表示该类型切片的字段。如：</p>
<ul>
<li><code>zap.Bool(key string, val bool) Field</code>：<code>bool</code>字段</li>
<li><code>zap.Boolp(key string, val *bool) Field</code>：<code>bool</code>指针字段；</li>
<li><code>zap.Bools(key string, val []bool) Field</code>：<code>bool</code>切片字段。</li>
</ul>
<p>当然也有一些特殊类型的字段：</p>
<ul>
<li><code>zap.Any(key string, value interface&#123;&#125;) Field</code>：任意类型的字段；</li>
<li><code>zap.Binary(key string, val []byte) Field</code>：二进制串的字段。</li>
</ul>
<p>当然，每个字段都用方法包一层用起来比较繁琐。<code>zap</code>也提供了便捷的方法<code>SugarLogger</code>，可以使用<code>printf</code>格式符的方式。调用<code>logger.Sugar()</code>即可创建<code>SugaredLogger</code>。<code>SugaredLogger</code>的使用比<code>Logger</code>简单，只是性能比<code>Logger</code>低 50% 左右，可以用在非热点函数中。调用<code>SugarLogger</code>以<code>f</code>结尾的方法与<code>fmt.Printf</code>没什么区别，如例子中的<code>Infof</code>。同时<code>SugarLogger</code>还支持以<code>w</code>结尾的方法，这种方式不需要先创建字段对象，直接将字段名和值依次放在参数中即可，如例子中的<code>Infow</code>。</p>
<p>默认情况下，<code>Example</code>输出的日志为 JSON 格式：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;failed to fetch URL&quot;,&quot;url&quot;:&quot;http://example.org/api&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;failed to fetch URL&quot;,&quot;url&quot;:&quot;http://example.org/api&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Failed to fetch URL: http://example.org/api&quot;&#125;</code></pre>

<h2 id="记录层级关系"><a href="#记录层级关系" class="headerlink" title="记录层级关系"></a>记录层级关系</h2><p>前面我们记录的日志都是一层结构，没有嵌套的层级。我们可以使用<code>zap.Namespace(key string) Field</code>构建一个<strong>命名空间</strong>，后续的<code>Field</code>都记录在此命名空间中：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger := zap.NewExample()
  <span class="hljs-keyword">defer</span> logger.Sync()

  logger.Info(<span class="hljs-string">&quot;tracked some metrics&quot;</span>,
    zap.Namespace(<span class="hljs-string">&quot;metrics&quot;</span>),
    zap.Int(<span class="hljs-string">&quot;counter&quot;</span>, <span class="hljs-number">1</span>),
  )

  logger2 := logger.With(
    zap.Namespace(<span class="hljs-string">&quot;metrics&quot;</span>),
    zap.Int(<span class="hljs-string">&quot;counter&quot;</span>, <span class="hljs-number">1</span>),
  )
  logger2.Info(<span class="hljs-string">&quot;tracked some metrics&quot;</span>)
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrics&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;tracked some metrices&quot;,&quot;metrics&quot;:&#123;&quot;counter&quot;:1&#125;&#125;</code></pre>

<p>上面我们演示了两种<code>Namespace</code>的用法，一种是直接作为字段传入<code>Debug/Info</code>等方法，一种是调用<code>With()</code>创建一个新的<code>Logger</code>，新的<code>Logger</code>记录日志时总是带上预设的字段。<code>With()</code>方法实际上是创建了一个新的<code>Logger</code>：</p>
<pre><code class="hljs go"><span class="hljs-comment">// src/go.uber.org/zap/logger.go</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(log *Logger)</span></span> With(fields ...Field) *Logger &#123;
  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fields) == <span class="hljs-number">0</span> &#123;
    <span class="hljs-keyword">return</span> log
  &#125;
  l := log.clone()
  l.core = l.core.With(fields)
  <span class="hljs-keyword">return</span> l
&#125;</code></pre>

<h2 id="定制Logger"><a href="#定制Logger" class="headerlink" title="定制Logger"></a>定制<code>Logger</code></h2><p>调用<code>NexExample()/NewDevelopment()/NewProduction()</code>这 3 个方法，<code>zap</code>使用默认的配置。我们也可以手动调整，配置结构如下：</p>
<pre><code class="hljs go"><span class="hljs-comment">// src/go.uber.org/zap/config.go</span>
<span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;
  Level AtomicLevel <span class="hljs-string">`json:&quot;level&quot; yaml:&quot;level&quot;`</span>
  Encoding <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;encoding&quot; yaml:&quot;encoding&quot;`</span>
  EncoderConfig zapcore.EncoderConfig <span class="hljs-string">`json:&quot;encoderConfig&quot; yaml:&quot;encoderConfig&quot;`</span>
  OutputPaths []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;outputPaths&quot; yaml:&quot;outputPaths&quot;`</span>
  ErrorOutputPaths []<span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;errorOutputPaths&quot; yaml:&quot;errorOutputPaths&quot;`</span>
  InitialFields <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;initialFields&quot; yaml:&quot;initialFields&quot;`</span>
&#125;</code></pre>

<ul>
<li><code>Level</code>：日志级别；</li>
<li><code>Encoding</code>：输出的日志格式，默认为 JSON；</li>
<li><code>OutputPaths</code>：可以配置多个输出路径，路径可以是文件路径和<code>stdout</code>（标准输出）；</li>
<li><code>ErrorOutputPaths</code>：错误输出路径，也可以是多个；</li>
<li><code>InitialFields</code>：每条日志中都会输出这些值。</li>
</ul>
<p>其中<code>EncoderConfig</code>为编码配置：</p>
<pre><code class="hljs go"><span class="hljs-comment">// src/go.uber.org/zap/zapcore/encoder.go</span>
<span class="hljs-keyword">type</span> EncoderConfig <span class="hljs-keyword">struct</span> &#123;
  MessageKey    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;messageKey&quot; yaml:&quot;messageKey&quot;`</span>
  LevelKey      <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;levelKey&quot; yaml:&quot;levelKey&quot;`</span>
  TimeKey       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;timeKey&quot; yaml:&quot;timeKey&quot;`</span>
  NameKey       <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;nameKey&quot; yaml:&quot;nameKey&quot;`</span>
  CallerKey     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;callerKey&quot; yaml:&quot;callerKey&quot;`</span>
  StacktraceKey <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;stacktraceKey&quot; yaml:&quot;stacktraceKey&quot;`</span>
  LineEnding    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;lineEnding&quot; yaml:&quot;lineEnding&quot;`</span>
  EncodeLevel    LevelEncoder    <span class="hljs-string">`json:&quot;levelEncoder&quot; yaml:&quot;levelEncoder&quot;`</span>
  EncodeTime     TimeEncoder     <span class="hljs-string">`json:&quot;timeEncoder&quot; yaml:&quot;timeEncoder&quot;`</span>
  EncodeDuration DurationEncoder <span class="hljs-string">`json:&quot;durationEncoder&quot; yaml:&quot;durationEncoder&quot;`</span>
  EncodeCaller   CallerEncoder   <span class="hljs-string">`json:&quot;callerEncoder&quot; yaml:&quot;callerEncoder&quot;`</span>
  EncodeName NameEncoder <span class="hljs-string">`json:&quot;nameEncoder&quot; yaml:&quot;nameEncoder&quot;`</span>
&#125;</code></pre>

<ul>
<li><code>MessageKey</code>：日志中信息的键名，默认为<code>msg</code>；</li>
<li><code>LevelKey</code>：日志中级别的键名，默认为<code>level</code>；</li>
<li><code>EncodeLevel</code>：日志中级别的格式，默认为小写，如<code>debug/info</code>。</li>
</ul>
<p>调用<code>zap.Config</code>的<code>Build()</code>方法即可使用该配置对象创建一个<code>Logger</code>：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  rawJSON := []<span class="hljs-type">byte</span>(<span class="hljs-string">`&#123;</span>
<span class="hljs-string">    &quot;level&quot;:&quot;debug&quot;,</span>
<span class="hljs-string">    &quot;encoding&quot;:&quot;json&quot;,</span>
<span class="hljs-string">    &quot;outputPaths&quot;: [&quot;stdout&quot;, &quot;server.log&quot;],</span>
<span class="hljs-string">    &quot;errorOutputPaths&quot;: [&quot;stderr&quot;],</span>
<span class="hljs-string">    &quot;initialFields&quot;:&#123;&quot;name&quot;:&quot;dj&quot;&#125;,</span>
<span class="hljs-string">    &quot;encoderConfig&quot;: &#123;</span>
<span class="hljs-string">      &quot;messageKey&quot;: &quot;message&quot;,</span>
<span class="hljs-string">      &quot;levelKey&quot;: &quot;level&quot;,</span>
<span class="hljs-string">      &quot;levelEncoder&quot;: &quot;lowercase&quot;</span>
<span class="hljs-string">    &#125;</span>
<span class="hljs-string">  &#125;`</span>)

  <span class="hljs-keyword">var</span> cfg zap.Config
  <span class="hljs-keyword">if</span> err := json.Unmarshal(rawJSON, &amp;cfg); err != <span class="hljs-literal">nil</span> &#123;
    <span class="hljs-built_in">panic</span>(err)
  &#125;
  logger, err := cfg.Build()
  <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
    <span class="hljs-built_in">panic</span>(err)
  &#125;
  <span class="hljs-keyword">defer</span> logger.Sync()

  logger.Info(<span class="hljs-string">&quot;server start work successfully!&quot;</span>)
&#125;</code></pre>

<p>上面创建一个输出到标准输出<code>stdout</code>和文件<code>server.log</code>的<code>Logger</code>。观察输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;message&quot;:&quot;server start work successfully!&quot;,&quot;name&quot;:&quot;dj&quot;&#125;</code></pre>

<p>|</p>
<p>使用<code>NewDevelopment()</code>创建的<code>Logger</code>使用的是如下的配置：</p>
<pre><code class="hljs go"><span class="hljs-comment">// src/go.uber.org/zap/config.go</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDevelopmentConfig</span><span class="hljs-params">()</span></span> Config &#123;
  <span class="hljs-keyword">return</span> Config&#123;
    Level:            NewAtomicLevelAt(DebugLevel),
    Development:      <span class="hljs-literal">true</span>, 
    Encoding:         <span class="hljs-string">&quot;console&quot;</span>,
    EncoderConfig:    NewDevelopmentEncoderConfig(),
    OutputPaths:      []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;stderr&quot;</span>&#125;,
    ErrorOutputPaths: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;stderr&quot;</span>&#125;,
  &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDevelopmentEncoderConfig</span><span class="hljs-params">()</span></span> zapcore.EncoderConfig &#123;
  <span class="hljs-keyword">return</span> zapcore.EncoderConfig&#123;
    <span class="hljs-comment">// Keys can be anything except the empty string.</span>
    TimeKey:        <span class="hljs-string">&quot;T&quot;</span>,
    LevelKey:       <span class="hljs-string">&quot;L&quot;</span>,
    NameKey:        <span class="hljs-string">&quot;N&quot;</span>,
    CallerKey:      <span class="hljs-string">&quot;C&quot;</span>,
    MessageKey:     <span class="hljs-string">&quot;M&quot;</span>,
    StacktraceKey:  <span class="hljs-string">&quot;S&quot;</span>,
    LineEnding:     zapcore.DefaultLineEnding,
    EncodeLevel:    zapcore.CapitalLevelEncoder,
    EncodeTime:     zapcore.ISO8601TimeEncoder,
    EncodeDuration: zapcore.StringDurationEncoder,
    EncodeCaller:   zapcore.ShortCallerEncoder,
  &#125;
&#125;</code></pre>

<p><code>NewProduction()</code>的配置可自行查看。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><code>NewExample()/NewDevelopment()/NewProduction()</code>这 3 个函数可以传入若干类型为<code>zap.Option</code>的选项，从而定制<code>Logger</code>的行为。又一次见到了<strong>选项模式</strong>！！</p>
<p><code>zap</code>提供了丰富的选项供我们选择。</p>
<h3 id="输出文件名和行号"><a href="#输出文件名和行号" class="headerlink" title="输出文件名和行号"></a>输出文件名和行号</h3><p>调用<code>zap.AddCaller()</code>返回的选项设置输出文件名和行号。但是有一个前提，必须设置配置对象<code>Config</code>中的<code>CallerKey</code>字段。也因此<code>NewExample()</code>不能输出这个信息（它的<code>Config</code>没有设置<code>CallerKey</code>）。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger, _ := zap.NewProduction(zap.AddCaller())
  <span class="hljs-keyword">defer</span> logger.Sync()

  logger.Info(<span class="hljs-string">&quot;hello world&quot;</span>)
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1587740198.9508286,&quot;caller&quot;:&quot;caller/main.go:9&quot;,&quot;msg&quot;:&quot;hello world&quot;&#125;</code></pre>

<p><code>Info()</code>方法在<code>main.go</code>的第 9 行被调用。<code>AddCaller()</code>与<code>zap.WithCaller(true)</code>等价。</p>
<p>有时我们稍微封装了一下记录日志的方法，但是我们希望输出的文件名和行号是调用封装函数的位置。这时可以使用<code>zap.AddCallerSkip(skip int)</code>向上跳 1 层：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Output</span><span class="hljs-params">(msg <span class="hljs-type">string</span>, fields ...zap.Field)</span></span> &#123;
  zap.L().Info(msg, fields...)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger, _ := zap.NewProduction(zap.AddCaller(), zap.AddCallerSkip(<span class="hljs-number">1</span>))
  <span class="hljs-keyword">defer</span> logger.Sync()

  zap.ReplaceGlobals(logger)

  Output(<span class="hljs-string">&quot;hello world&quot;</span>)
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1587740501.5592482,&quot;caller&quot;:&quot;skip/main.go:15&quot;,&quot;msg&quot;:&quot;hello world&quot;&#125;</code></pre>

<p>输出在<code>main</code>函数中调用<code>Output()</code>的位置。如果不指定<code>zap.AddCallerSkip(1)</code>，将输出<code>&quot;caller&quot;:&quot;skip/main.go:6&quot;</code>，这是在<code>Output()</code>函数中调用<code>zap.Info()</code>的位置。因为这个<code>Output()</code>函数可能在很多地方被调用，所以这个位置参考意义并不大。试试看！</p>
<h3 id="输出调用堆栈"><a href="#输出调用堆栈" class="headerlink" title="输出调用堆栈"></a>输出调用堆栈</h3><p>有时候在某个函数处理中遇到了异常情况，因为这个函数可能在很多地方被调用。如果我们能输出此次调用的堆栈，那么分析起来就会很方便。我们可以使用<code>zap.AddStackTrace(lvl zapcore.LevelEnabler)</code>达成这个目的。该函数指定<code>lvl</code>和之上的级别都需要输出调用堆栈：</p>
<p>|</p>
<pre><code class="hljs go">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span> &#123;
  f2(<span class="hljs-string">&quot;hello world&quot;</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(msg <span class="hljs-type">string</span>, fields ...zap.Field)</span></span> &#123;
  zap.L().Warn(msg, fields...)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger, _ := zap.NewProduction(zap.AddStacktrace(zapcore.WarnLevel))
  <span class="hljs-keyword">defer</span> logger.Sync()

  zap.ReplaceGlobals(logger)

  f1()
&#125;</code></pre>

<p>将<code>zapcore.WarnLevel</code>传入<code>AddStacktrace()</code>，之后<code>Warn()/Error()</code>等级别的日志会输出堆栈，<code>Debug()/Info()</code>这些级别不会。运行结果：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;warn&quot;,&quot;ts&quot;:1587740883.4965692,&quot;caller&quot;:&quot;stacktrace/main.go:13&quot;,&quot;msg&quot;:&quot;hello world&quot;,&quot;stacktrace&quot;:&quot;main.f2\n\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:13\nmain.f1\n\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:9\nmain.main\n\td:/code/golang/src/github.com/darjun/go-daily-lib/zap/option/stacktrace/main.go:22\nruntime.main\n\tC:/Go/src/runtime/proc.go:203&quot;&#125;</code></pre>

<p>|</p>
<p>把<code>stacktrace</code>单独拉出来：</p>
<p>很清楚地看到调用路径。</p>
<h2 id="全局Logger"><a href="#全局Logger" class="headerlink" title="全局Logger"></a>全局<code>Logger</code></h2><p>为了方便使用，<code>zap</code>提供了两个全局的<code>Logger</code>，一个是<code>*zap.Logger</code>，可调用<code>zap.L()</code>获得；另一个是<code>*zap.SugaredLogger</code>，可调用<code>zap.S()</code>获得。需要注意的是，全局的<code>Logger</code>默认并不会记录日志！它是一个无实际效果的<code>Logger</code>。看源码:</p>
<pre><code class="hljs go"><span class="hljs-comment">// go.uber.org/zap/global.go</span>
<span class="hljs-keyword">var</span> (
  _globalMu sync.RWMutex
  _globalL  = NewNop()
  _globalS  = _globalL.Sugar()
)</code></pre>

<p>我们可以使用<code>ReplaceGlobals(logger *Logger) func()</code>将<code>logger</code>设置为全局的<code>Logger</code>，该函数返回一个无参函数，用于恢复全局<code>Logger</code>设置：</p>
<pre><code class="hljs go">

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  zap.L().Info(<span class="hljs-string">&quot;global Logger before&quot;</span>)
  zap.S().Info(<span class="hljs-string">&quot;global SugaredLogger before&quot;</span>)

  logger := zap.NewExample()
  <span class="hljs-keyword">defer</span> logger.Sync()

  zap.ReplaceGlobals(logger)
  zap.L().Info(<span class="hljs-string">&quot;global Logger after&quot;</span>)
  zap.S().Info(<span class="hljs-string">&quot;global SugaredLogger after&quot;</span>)
&#125;</code></pre>

<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;global Logger after&quot;&#125;
&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;global SugaredLogger after&quot;&#125;</code></pre>

<p>可以看到在调用<code>ReplaceGlobals</code>之前记录的日志并没有输出。</p>
<h3 id="预设日志字段"><a href="#预设日志字段" class="headerlink" title="预设日志字段"></a>预设日志字段</h3><p>如果每条日志都要记录一些共用的字段，那么使用<code>zap.Fields(fs ...Field)</code>创建的选项。例如在服务器日志中记录可能都需要记录<code>serverId</code>和<code>serverName</code>：</p>
<p>|</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger := zap.NewExample(zap.Fields(
    zap.Int(<span class="hljs-string">&quot;serverId&quot;</span>, <span class="hljs-number">90</span>),
    zap.String(<span class="hljs-string">&quot;serverName&quot;</span>, <span class="hljs-string">&quot;awesome web&quot;</span>),
  ))

  logger.Info(<span class="hljs-string">&quot;hello world&quot;</span>)
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;hello world&quot;,&quot;serverId&quot;:90,&quot;serverName&quot;:&quot;awesome web&quot;&#125;</code></pre>

<h2 id="与标准日志库搭配使用"><a href="#与标准日志库搭配使用" class="headerlink" title="与标准日志库搭配使用"></a>与标准日志库搭配使用</h2><p>如果项目一开始使用的是标准日志库<code>log</code>，后面想转为<code>zap</code>。这时不必修改每一个文件。我们可以调用<code>zap.NewStdLog(l *Logger) *log.Logger</code>返回一个标准的<code>log.Logger</code>，内部实际上写入的还是我们之前创建的<code>zap.Logger</code>：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger := zap.NewExample()
  <span class="hljs-keyword">defer</span> logger.Sync()

  std := zap.NewStdLog(logger)
  std.Print(<span class="hljs-string">&quot;standard logger wrapper&quot;</span>)
&#125;</code></pre>

<p>输出：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;standard logger wrapper&quot;&#125;</code></pre>

<p>很方便不是吗？我们还可以使用<code>NewStdLogAt(l *logger, level zapcore.Level) (*log.Logger, error)</code>让标准接口以<code>level</code>级别写入内部的<code>*zap.Logger</code>。</p>
<p>如果我们只是想在一段代码内使用标准日志库<code>log</code>，其它地方还是使用<code>zap.Logger</code>。可以调用<code>RedirectStdLog(l *Logger) func()</code>。它会返回一个无参函数恢复设置：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
  logger := zap.NewExample()
  <span class="hljs-keyword">defer</span> logger.Sync()

  undo := zap.RedirectStdLog(logger)
  log.Print(<span class="hljs-string">&quot;redirected standard library&quot;</span>)
  undo()

  log.Print(<span class="hljs-string">&quot;restored standard library&quot;</span>)
&#125;</code></pre>

<p>看前后输出变化：</p>
<pre><code class="hljs Linux">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;redirected standard library&quot;&#125;
2020/04/24 22:13:58 restored standard library</code></pre>

<p>|</p>
<p>当然<code>RedirectStdLog</code>也有一个对应的<code>RedirectStdLogAt</code>以特定的级别调用内部的<code>*zap.Logger</code>方法。</p>
<h2 id="惊喜来啦-通用zap封装拿走直接用"><a href="#惊喜来啦-通用zap封装拿走直接用" class="headerlink" title="惊喜来啦 通用zap封装拿走直接用"></a>惊喜来啦 通用zap封装拿走直接用</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> common
<span class="hljs-comment">/*</span>
<span class="hljs-comment">Package common provides a logging utility that utilizes the Zap logger library</span>
<span class="hljs-comment">for structured and performant logging. It includes functions for logging at</span>
<span class="hljs-comment">different log levels and is configured to write log entries to a file using</span>
<span class="hljs-comment">the Lumberjack log rotation mechanism.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">Author: wujiahao</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">Initial Description:</span>
<span class="hljs-comment">This package sets up a structured logging system using Uber&#x27;s Zap logger and</span>
<span class="hljs-comment">Lumberjack for log rotation. It allows you to log messages at different</span>
<span class="hljs-comment">severity levels, such as Debug, Info, Warn, Error, DPanic, and Fatal, and</span>
<span class="hljs-comment">supports both plain and formatted log messages. The log output is directed to</span>
<span class="hljs-comment">a file with rotation based on size, and each log entry includes a timestamp</span>
<span class="hljs-comment">in ISO8601 format. Additionally, caller information can be included in log</span>
<span class="hljs-comment">entries for debugging purposes.</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">Usage:</span>
<span class="hljs-comment">To use this logging utility, simply import the package and make calls to the</span>
<span class="hljs-comment">logging functions as needed. The logger is initialized with default</span>
<span class="hljs-comment">configuration, but you can customize it by modifying the init() function in</span>
<span class="hljs-comment">this package.</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;go.uber.org/zap&quot;</span>
	<span class="hljs-string">&quot;go.uber.org/zap/zapcore&quot;</span>
	<span class="hljs-string">&quot;gopkg.in/natefinch/lumberjack.v2&quot;</span>
)




<span class="hljs-keyword">var</span> (
	logger *zap.SugaredLogger
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;
	<span class="hljs-comment">//log file name</span>
	fileName :=<span class="hljs-string">&quot;micro.log&quot;</span>
	writeSyncer := zapcore.AddSync(&amp;lumberjack.Logger&#123;
		Filename: fileName, <span class="hljs-comment">//file name</span>
		MaxSize:  <span class="hljs-number">521</span>,      <span class="hljs-comment">//the file max size *MB</span>
		<span class="hljs-comment">//MaxAge:     0,		//the destroy time</span>
		MaxBackups: <span class="hljs-number">0</span>,    <span class="hljs-comment">//the max back up</span>
		LocalTime:  <span class="hljs-literal">true</span>, <span class="hljs-comment">//start local time</span>
		Compress:   <span class="hljs-literal">true</span>, <span class="hljs-comment">//is zip</span>
	&#125;)
	<span class="hljs-comment">//encode</span>
	encoder := zap.NewProductionEncoderConfig()
	<span class="hljs-comment">//time format</span>
	encoder.EncodeTime = zapcore.ISO8601TimeEncoder
	core := zapcore.NewCore(
		<span class="hljs-comment">//encoder</span>
		zapcore.NewJSONEncoder(encoder),
		writeSyncer,
		zap.NewAtomicLevelAt(zap.DebugLevel))
	log := zap.New(
		core,
		zap.AddCaller(),
		zap.AddCallerSkip(<span class="hljs-number">1</span>))<span class="hljs-comment">//有时我们稍微封装了一下记录日志的方法，但是我们希望输出的文件名和行号是调用封装函数的位置。这时可以使用zap.AddCallerSkip(skip int)向上跳 1 层：</span>
	logger= log.Sugar()
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Debug</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Debug(args)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Debugf</span><span class="hljs-params">(template <span class="hljs-type">string</span>,args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;
	logger.Debugf(template, args)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Info</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
     logger.Info(args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Infof</span><span class="hljs-params">(template <span class="hljs-type">string</span>,arg ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Infof(template,arg...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Warn</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Warn(args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Warnf</span><span class="hljs-params">(template <span class="hljs-type">string</span>,args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Warnf(template,args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Error</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Error(args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(template <span class="hljs-type">string</span>,args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Errorf(template,args)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DPanic</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.DPanic(args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DPanicf</span><span class="hljs-params">(template <span class="hljs-type">string</span>,args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.DPanicf(template,args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fatal</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Fatal(args...)
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FatalF</span><span class="hljs-params">(tempalte <span class="hljs-type">string</span>,args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	logger.Fatalf(tempalte,args...)
&#125;</code></pre>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>zap</code>库，我们可以轻松地实现高性能、结构化的日志记录，同时减少内存分配和性能损失。</p>
<p>本文从安装、快速使用、配置、全局<code>Logger</code>等方面介绍了<code>zap</code>的基本用法。</p>
<p>它的性能和优势使得它成为处理热点函数中日志记录的首选工具。</p>
<p>通过掌握<code>zap</code>库，开发人员可以更好地管理和分析应用程序的日志，提高开发和维护效率，确保应用程序的稳定性和可维护性。</p>
<p>因此，我们鼓励开发人员深入学习和应用<code>zap</code>库，以提高<code>Go</code>语言应用程序的日志记录质量和性能。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>zap GitHub：<a target="_blank" rel="noopener" href="https://github.com/uber-go/zap" title="https://github.com/uber-go/zap">github.com&#x2F;uber-go&#x2F;zap</a></li>
</ol>
<p>2、原先自己写的地址:<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/696dec722935" title="https://www.jianshu.com/p/696dec722935">www.jianshu.com/p/696dec722…</a></p>

  </article>

  <div class="nexmoe-post-meta nexmoe-rainbow">
    
        <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/">技术文章</a>
    
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/go/" rel="tag">go</a> <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a>
    
</div>

  <div class="nexmoe-post-footer">
    
      

    
    <section class="nexmoe-comment">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.css">
<div id="gitalk"></div>
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.5.0/dist/gitalk.min.js"></script>
<script type="text/javascript">
    var gitalk = new Gitalk({
        clientID: 'b1032eb4eb5c3aa428db',
        clientSecret: '1318f0e4e87894bf79a3353a0c372a0316e00dde',
        id: window.location.pathname,
        repo: 'blog',
        owner: 'ruanzhijun',
        admin: 'ruanzhijun'
    })
    gitalk.render('gitalk')
</script>
</section>
  </div>
</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@10.1.1/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js,gh/nexmoe/nexmoe.github.io@latest/js/app.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!--<script src="/js/app.js?v=1730783323605"></script>-->


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>




  





</body>

</html>
